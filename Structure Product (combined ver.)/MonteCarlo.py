# -*- coding: utf-8 -*-
"""simu.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HW4cVtR7EMPlHGr6uEXptgFIMurlh07E
"""

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from scipy.stats import norm
import exchange_calendars as xcals
import datetime as dt
from statistics import mean 
import time
import random
from math import sqrt, exp

def get_stock_price(tickers,data_start,data_end):
  """
  # retrieve stocks' historical adjusted close price
  # tickers: assets tickers
  # data_start/end: retreive start/end date
  """
  stockPrice_df = pd.DataFrame()

  for t in tickers:
      stockPrice_df[t] = yf.download(t, start=data_start, end = data_end, progress=False)['Adj Close'] 

  return stockPrice_df

def print_stock_plot(tickers,stockPrice_df, title = "Stock Price",\
                     hori_line = None,hori_label=None,\
                     verti_line = None,verti_label=None):
  """
  # Print historical stock price
  # tickers: assets tickers
  # stockPrice_df: target assets historical stock price data frame/array
  # hori_line(optional): list with value(s) to draw horizontal line(s)
  # hori_label(optional): list with label(s) for horizontal line(s) 
  # verti_line(optional): list with value(s)/datetime to draw vertical line(s)
  # verti_label(optional): list with label(s) for vertical line(s) 
  """
  plt.plot(stockPrice_df,label = tickers)
  color = ['r','orange','y','k']
  
  if hori_line != None:
    for i in range(len(hori_line)):
      plt.axhline(y = hori_line[i], label = hori_label[i], linestyle="-",color = color[i])
  
  if verti_line != None:
    for i in range(len(verti_line)):
      plt.axvline(x = verti_line[i], label = verti_label[i], linestyle=":",color = color[-i])
    
  plt.title(title)
  plt.legend()
  return plt

def discount_rate(day_count,rf,day_count_basis):
  """
  # Calculate discount factor
  # day_count: actual days
  # rf: risk-free rate
  # day_count_basis: 360 or 365 days
  """
  return 1/(1+rf)**(day_count/day_count_basis)
  
  
def get_volatility(stockPrice_df):
  try: 
    log_return_df = np.log(stockPrice_df/stockPrice_df.shift(1))
  except: 
    s=pd.DataFrame(stockPrice_df)
    log_return_df = np.log(s/s.shift(1))
  return log_return_df.std()*np.sqrt(252)
  
  
def single_asset_simulation(T,stock_price,rf,n_simulation,S0):
  """
  # Run Monte Carlo Simulation for single-asset
  # T: simulate time length (days)
  # stock_price: target assets historical stock price data frame
  # rf: risk free rate
  # n_simulation:number
  # S0: initial price
  """

  dt = 1 /252
  #log return of stock price
  log_return_df = np.log(stock_price/stock_price.shift(1))

  #calculate historical volatility
  v = log_return_df.std().values * np.sqrt(252)
  return_array =  np.exp((rf - 0.5 * v**2) * dt + v * np.sqrt(dt) * norm.ppf(np.random.rand(T,n_simulation)))

  stock_price_array = np.zeros((T,n_simulation))
  #set initial price
  stock_price_array[0] = S0

  np.random.seed(0)
  for t in range(1, T):
    stock_price_array[t] = stock_price_array[t-1] * return_array[t]
  return stock_price_array
  
  

def multi_assets_simulation(T,stock_price,rf,n_simulation,initial_price):
  """
  # Run Monte Carlo Simulation for Multi-assets
  # T: simulate time length (days)
  # stock_price: target assets historical stock price data frame
  # rf: risk free rate
  # n_simulation:number
  """
  dt = 1 /252
  n_stock = stock_price.shape[1]
  #log return of stock price
  log_return_df = np.log(stock_price/stock_price.shift(1))

  #calculate coefficient correlation matrix
  coef_matrix = np.corrcoef(stock_price.dropna(),rowvar=False)

  #calculate cholesky decomposition
  R= np.linalg.cholesky(coef_matrix)

  #calculate historical volatility
  volatility_array = log_return_df.std()*sqrt(252)

  stock_price_array = np.zeros((n_stock,T,n_simulation))
  #set initial price
  stock_price_array[:,0,:] =np.multiply(np.ones((n_simulation, n_stock)),\
                                            initial_price.to_numpy()).T#\
                                     #   stock_price.iloc[-1,:].to_numpy()[:,None])
  np.random.seed(0)
  for t in range(1, T):
    
    # Generate array of random standard normal draws
    random_array = np.random.standard_normal((n_stock,n_simulation))
    
    # Multiply R (from factorization) with random_array to obtain correlated epsilons
    epsilon_array = np.reshape([np.inner(random_array[:,i],R) for i in range(n_simulation)],(n_stock,n_simulation))

    # Sample price path per stock
    for n in range(n_stock):
        S = stock_price_array[n,t-1,:]
        v = volatility_array[n]
        epsilon = epsilon_array[n,:]
        # Generate new stock price
        stock_price_array[n,t,:] = S * np.exp((rf - 0.5 * v**2) * dt + v * sqrt(dt) * epsilon)
  return stock_price_array